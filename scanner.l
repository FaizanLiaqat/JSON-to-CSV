/* scanner.l */
%{
#define _POSIX_C_SOURCE 200809L /* MUST BE FIRST (or other appropriate feature macro) */

#include <stdio.h>    // For fileno (with POSIX_C_SOURCE), fprintf, YY_USER_ACTION uses yylloc.first_line etc.
#include <string.h>   // For strdup
#include <stdlib.h>   // For exit(), EXIT_FAILURE. Malloc is used by strdup.
#include <unistd.h>   // For isatty. Flex's generated code uses isatty.

#include "ast.h"      // For JsonValue struct (used by parser.h's yylval) AND unescape_json_string
#include "parser.h"   // Generated by Bison, contains token definitions & yylval (which needs JsonValue known)

/* Make yylloc available to an LALR parser produced by Bison. */
#define YY_USER_ACTION \
    yylloc.first_line = yylloc.last_line = yylineno; \
    yylloc.first_column = yycolumn; \
    yylloc.last_column = yycolumn + yyleng - 1; \
    yycolumn += yyleng;

/* Global column tracker for Flex itself */
int yycolumn = 1;
%}

%option yylineno
%option noyywrap nounput noinput batch debug
/* Regular expressions for tokens */
DIGIT    [0-9]
INTEGER  ("0"|([1-9]{DIGIT}*))
NUMBER (-?{INTEGER}(\.{DIGIT}+)?([eE][+-]?{INTEGER})?)
/* Strings: a bit tricky with escapes. Flex matches greedily. */
/* The unescape_json_string function will handle content. */
STRING   \"([^\"\\]|\\.)*\"
WHITESPACE [ \t\r]+

%%
{WHITESPACE}  { /* Ignore whitespace, action updates yycolumn via YY_USER_ACTION */ }
"\n"          { yycolumn = 1; /* yylineno is updated by %option yylineno */ }
"{"           { return TOKEN_LBRACE; }
"}"           { return TOKEN_RBRACE; }
"["           { return TOKEN_LBRACKET; }
"]"           { return TOKEN_RBRACKET; }
","           { return TOKEN_COMMA; }
":"           { return TOKEN_COLON; }
"true"        { yylval.bool_val = 1; return TOKEN_TRUE; }
"false"       { yylval.bool_val = 0; return TOKEN_FALSE; }
"null"        { return TOKEN_NULL; }

{NUMBER}      {
                yylval.string_val = (char *)malloc(yyleng + 1); 
                if (!yylval.string_val) {
                    fprintf(stderr, "FATAL: malloc failed in lexer for NUMBER text\n");
                    exit(EXIT_FAILURE); // Or exit(1) as you had
                }
                memcpy(yylval.string_val, yytext, yyleng); // Copy yyleng bytes
                yylval.string_val[yyleng] = '\0';
                return TOKEN_NUMBER;
              }
{STRING}      {
                /* yytext includes the quotes. yyleng is the length including quotes. */
                /* unescape_json_string will remove quotes and process escapes. */
                /* It returns a new heap-allocated string. */
                yylval.string_val = unescape_json_string(yytext, yyleng);
                return TOKEN_STRING;
              }
.             {
                fprintf(stderr, "Lexical Error: Unexpected character '%s' at line %d, column %d\n",
                        yytext, yylineno, yylloc.first_column);
                exit(1);
              }

%%
/*
// yywrap is not needed due to %option noyywrap
// If it were:
// int yywrap() { return 1; }
*/